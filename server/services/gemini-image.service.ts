import { GoogleGenerativeAI } from '@google/generative-ai';
import { config } from '../config.js';
import { logger } from '../logger.js';

interface GenerateImageOptions {
  prompt: string;
  previousImage?: string; // Base64 encoded image for editing
  aspectRatio?: string;
}

interface GenerateImageResult {
  imageBase64: string;
  text?: string;
}

export class GeminiImageService {
  private client: GoogleGenerativeAI;
  private model: string = 'gemini-2.0-flash-exp-image-generation'; // Nano Banana - Gemini image generation model

  constructor() {
    if (!config.geminiApiKey) {
      logger.warn('‚ö†Ô∏è Gemini API key not set - image generation will not work');
    }
    this.client = new GoogleGenerativeAI(config.geminiApiKey || '');
  }

  /**
   * Generate an image from a text prompt
   */
  async generateImage(options: GenerateImageOptions): Promise<GenerateImageResult> {
    const { prompt, previousImage, aspectRatio = '1:1' } = options;

    logger.info('üé® Generating image with Gemini', { 
      promptLength: prompt.length,
      hasExistingImage: !!previousImage,
      aspectRatio,
    });

    try {
      const model = this.client.getGenerativeModel({
        model: this.model,
        generationConfig: {
          // @ts-ignore - Gemini image generation config
          responseModalities: ['Text', 'Image'],
        },
      });

      let contents: any[];

      if (previousImage) {
        // Image editing - include the previous image
        contents = [
          {
            role: 'user',
            parts: [
              { text: prompt },
              {
                inlineData: {
                  mimeType: 'image/png',
                  data: previousImage,
                },
              },
            ],
          },
        ];
      } else {
        // Text-to-image generation
        contents = [
          {
            role: 'user',
            parts: [{ text: prompt }],
          },
        ];
      }

      const result = await model.generateContent({
        contents,
        // @ts-ignore - Gemini image generation config
        generationConfig: {
          responseModalities: ['Text', 'Image'],
        },
      });

      const response = result.response;
      let imageBase64: string | null = null;
      let text: string | undefined;

      // Process the response parts
      for (const candidate of response.candidates || []) {
        for (const part of candidate.content?.parts || []) {
          if (part.text) {
            text = part.text;
            logger.debug('üìù Received text response from Gemini', { textLength: text.length });
          }
          if (part.inlineData) {
            imageBase64 = part.inlineData.data;
            logger.info('üñºÔ∏è Received image from Gemini', { 
              mimeType: part.inlineData.mimeType,
              dataLength: imageBase64?.length || 0,
            });
          }
        }
      }

      if (!imageBase64) {
        throw new Error('No image was generated by Gemini');
      }

      return {
        imageBase64,
        text,
      };
    } catch (error) {
      logger.error(error, { context: 'gemini_image_generation' });
      throw error;
    }
  }

  /**
   * Edit an existing image based on a text prompt
   */
  async editImage(prompt: string, existingImageBase64: string): Promise<GenerateImageResult> {
    return this.generateImage({
      prompt,
      previousImage: existingImageBase64,
    });
  }

  /**
   * Create a chat session for multi-turn image editing
   */
  createImageChat() {
    const model = this.client.getGenerativeModel({
      model: this.model,
      generationConfig: {
        // @ts-ignore - Gemini image generation config
        responseModalities: ['Text', 'Image'],
      },
    });

    const chat = model.startChat({
      history: [],
      generationConfig: {
        // @ts-ignore
        responseModalities: ['Text', 'Image'],
      },
    });

    return {
      /**
       * Send a message in the image chat (supports text and images)
       */
      sendMessage: async (prompt: string, imageBase64?: string): Promise<GenerateImageResult> => {
        logger.info('üí¨ Sending message to Gemini image chat', {
          promptLength: prompt.length,
          hasImage: !!imageBase64,
        });

        try {
          let parts: any[];

          if (imageBase64) {
            parts = [
              { text: prompt },
              {
                inlineData: {
                  mimeType: 'image/png',
                  data: imageBase64,
                },
              },
            ];
          } else {
            parts = [{ text: prompt }];
          }

          const result = await chat.sendMessage(parts);
          const response = result.response;

          let resultImageBase64: string | null = null;
          let text: string | undefined;

          for (const candidate of response.candidates || []) {
            for (const part of candidate.content?.parts || []) {
              if (part.text) {
                text = part.text;
              }
              if (part.inlineData) {
                resultImageBase64 = part.inlineData.data;
              }
            }
          }

          if (!resultImageBase64) {
            throw new Error('No image was generated');
          }

          return {
            imageBase64: resultImageBase64,
            text,
          };
        } catch (error) {
          logger.error(error, { context: 'gemini_image_chat' });
          throw error;
        }
      },
    };
  }
}
